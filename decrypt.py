import os
import base64
import argparse
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes


def decrypt_AES(key, msg, padding_mode='CBC', iv=None):
    key = base64.b64decode(key)
    msg = base64.b64decode(msg)
    if not iv:
        iv = b'\x00' * 16
    else:
        iv = base64.b64decode(iv)

    if len(key) == 16:
        algo = algorithms.AES(key)
    elif len(key) == 24:
        algo = algorithms.AES(key)
    elif len(key) == 32:
        algo = algorithms.AES(key)
    else:
        raise ValueError("Invalid key size. Must be 16, 24, or 32 bytes.")

    if padding_mode == 'CBC':
        pad = modes.CBC(iv)
    elif padding_mode == 'ECB':
        pad = modes.ECB()
    else:
        raise ValueError("Invalid padding mode. Must be 'CBC' or 'ECB'.")

    cipher = Cipher(algo, pad, backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(msg) + decryptor.finalize()
    return decrypted_data

def main():
    parser = argparse.ArgumentParser(description="Decrypt AES encoded messages")
    parser.add_argument("-key", "--key_file", required=True, help="File containing base64 encoded key")
    parser.add_argument("-msg", "--msg_file", required=True, help="File containing base64 encoded message")
    parser.add_argument("-output", "--output_file", help="File to write decrypted message to")
    parser.add_argument("-padding", "--padding_mode", required=True, default='CBC', help="Padding mode to use. Must be 'CBC' or 'ECB'. Default is 'CBC'.")
    args = parser.parse_args()
    key = open(args.key_file, 'r').read()
    msg = open(args.msg_file, 'r').read()
    decrypted_msg = decrypt_AES(key, msg, args.padding_mode)
    if args.output_file:
        with open(args.output_file, 'wb') as f:
            f.write(decrypted_msg)
    else:
        print(decrypted_msg)

if __name__ == '__main__':
    main()
